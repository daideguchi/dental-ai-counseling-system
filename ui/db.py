#!/usr/bin/env python3
"""
SQLite persistence helper for Dental Counseling AI

Stores full JSONL record and selected indexes for quick lookup.
No external dependencies. Safe to import from demo/api server.
"""

from __future__ import annotations

import json
import sqlite3
from pathlib import Path
from typing import Any, Dict


DB_FILENAME = "dental_counseling.db"


SCHEMA_SQL = """
CREATE TABLE IF NOT EXISTS jsonl_records (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  session_id TEXT UNIQUE,
  timestamp TEXT,
  patient_name TEXT,
  doctor_name TEXT,
  filename TEXT,
  filesize INTEGER,
  json_data TEXT
);

CREATE INDEX IF NOT EXISTS idx_jsonl_records_session ON jsonl_records(session_id);
CREATE INDEX IF NOT EXISTS idx_jsonl_records_timestamp ON jsonl_records(timestamp);
CREATE INDEX IF NOT EXISTS idx_jsonl_records_patient ON jsonl_records(patient_name);
"""


def get_db_path() -> Path:
    # DB is stored next to server files under ui/
    return Path(__file__).parent / DB_FILENAME


def connect(db_path: Path | None = None) -> sqlite3.Connection:
    path = db_path or get_db_path()
    conn = sqlite3.connect(str(path))
    conn.execute("PRAGMA journal_mode=WAL;")
    conn.execute("PRAGMA synchronous=NORMAL;")
    return conn


def init_db(conn: sqlite3.Connection) -> None:
    conn.executescript(SCHEMA_SQL)
    conn.commit()


def save_jsonl_record(conn: sqlite3.Connection, record: Dict[str, Any]) -> str:
    """
    Persist a JSONL record (same structure as generated by UI).
    Returns the session_id.
    """
    # Extract fields safely
    session_id = record.get("session_id") or record.get("processed_data", {}).get("identification", {}).get("session_id")
    timestamp = record.get("timestamp")
    original = record.get("original_data", {})
    filename = original.get("filename")
    filesize = original.get("filesize")
    processed = record.get("processed_data", {})
    identification = processed.get("identification", {})
    patient_name = identification.get("patient_name")
    doctor_name = identification.get("doctor_name")

    if not session_id:
        # Generate a fallback session id if missing
        from time import time
        session_id = f"session_{int(time()*1000)}"

    json_text = json.dumps(record, ensure_ascii=False)

    conn.execute(
        """
        INSERT INTO jsonl_records (session_id, timestamp, patient_name, doctor_name, filename, filesize, json_data)
        VALUES (?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT(session_id) DO UPDATE SET
          timestamp=excluded.timestamp,
          patient_name=excluded.patient_name,
          doctor_name=excluded.doctor_name,
          filename=excluded.filename,
          filesize=excluded.filesize,
          json_data=excluded.json_data
        """,
        (
            session_id,
            timestamp,
            patient_name,
            doctor_name,
            filename,
            filesize,
            json_text,
        ),
    )
    conn.commit()
    return session_id


def load_session(conn: sqlite3.Connection, session_id: str) -> Dict[str, Any] | None:
    cur = conn.execute(
        "SELECT json_data FROM jsonl_records WHERE session_id=?", (session_id,)
    )
    row = cur.fetchone()
    if not row:
        return None
    return json.loads(row[0])

